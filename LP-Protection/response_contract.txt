// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

interface IUniswapV2Pair {
    function balanceOf(address owner) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function burn(address to) external returns (uint256 amount0, uint256 amount1);
    function token0() external view returns (address);
    function token1() external view returns (address);
    function totalSupply() external view returns (uint256);
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
}

/**
 * @title LiquidityWithdrawer
 * @dev Response contract that handles emergency withdrawal of liquidity
 */
contract LiquidityWithdrawer {
    
    event EmergencyWithdrawal(
        address indexed user,
        address indexed pool,
        uint256 liquidityAmount,
        uint256 amount0,
        uint256 amount1,
        uint256 percentageDrop
    );
    
    event WithdrawalFailed(
        address indexed user,
        address indexed pool,
        string reason
    );
    
    // Access control
    mapping(address => bool) public authorizedCallers;
    address public owner;
    
    modifier onlyAuthorized() {
        require(authorizedCallers[msg.sender] || msg.sender == owner, "Not authorized");
        _;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    constructor() {
        owner = msg.sender;
        authorizedCallers[msg.sender] = true;
    }
    
    /**
     * @dev Add authorized caller (typically Drosera operators)
     */
    function addAuthorizedCaller(address caller) external onlyOwner {
        authorizedCallers[caller] = true;
    }
    
    /**
     * @dev Remove authorized caller
     */
    function removeAuthorizedCaller(address caller) external onlyOwner {
        authorizedCallers[caller] = false;
    }
    
    /**
     * @dev Emergency withdrawal function called by Drosera when trap triggers
     * @param user The user whose liquidity to withdraw
     * @param pool The liquidity pool contract address
     * @param currentLiquidity Current liquidity amount (for logging)
     * @param percentageDrop Percentage drop that triggered this withdrawal
     */
    function emergencyWithdraw(
        address user,
        address pool,
        uint256 currentLiquidity,
        uint256 percentageDrop
    ) external onlyAuthorized {
        
        try this._performWithdrawal(user, pool) returns (uint256 amount0, uint256 amount1) {
            emit EmergencyWithdrawal(
                user,
                pool,
                currentLiquidity,
                amount0,
                amount1,
                percentageDrop
            );
        } catch Error(string memory reason) {
            emit WithdrawalFailed(user, pool, reason);
        } catch {
            emit WithdrawalFailed(user, pool, "Unknown error during withdrawal");
        }
    }
    
    /**
     * @dev Internal function to perform the actual withdrawal
     * @param user The user whose liquidity to withdraw
     * @param pool The liquidity pool contract address
     * @return amount0 Amount of token0 withdrawn
     * @return amount1 Amount of token1 withdrawn
     */
    function _performWithdrawal(
        address user,
        address pool
    ) external returns (uint256 amount0, uint256 amount1) {
        require(msg.sender == address(this), "Internal function only");
        
        IUniswapV2Pair pair = IUniswapV2Pair(pool);
        
        // Get user's LP token balance
        uint256 liquidityBalance = pair.balanceOf(user);
        require(liquidityBalance > 0, "No liquidity to withdraw");
        
        // Transfer LP tokens to this contract for burning
        // Note: This requires user to have pre-approved this contract
        require(pair.transfer(address(this), liquidityBalance), "LP transfer failed");
        
        // Burn the LP tokens and receive underlying tokens
        (amount0, amount1) = pair.burn(user);
        
        require(amount0 > 0 || amount1 > 0, "No tokens received from burn");
        
        return (amount0, amount1);
    }
    
    /**
     * @dev Alternative withdrawal method using permit (if supported by LP token)
     * This allows withdrawal without pre-approval
     */
    function emergencyWithdrawWithPermit(
        address user,
        address pool,
        uint256 currentLiquidity,
        uint256 percentageDrop,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external onlyAuthorized {
        // Implementation would depend on LP token supporting permit
        // This is a placeholder for advanced functionality
        revert("Permit withdrawal not implemented");
    }
    
    /**
     * @dev Get withdrawal preview without executing
     * @param user The user address
     * @param pool The pool address
     * @return amount0 Expected amount of token0
     * @return amount1 Expected amount of token1
     */
    function previewWithdrawal(
        address user,
        address pool
    ) external view returns (uint256 amount0, uint256 amount1) {
        IUniswapV2Pair pair = IUniswapV2Pair(pool);
        uint256 liquidityBalance = pair.balanceOf(user);
        
        if (liquidityBalance == 0) {
            return (0, 0);
        }
        
        uint256 totalSupply = pair.totalSupply();
        (uint112 reserve0, uint112 reserve1,) = pair.getReserves();
        
        // Calculate proportional amounts
        amount0 = (liquidityBalance * reserve0) / totalSupply;
        amount1 = (liquidityBalance * reserve1) / totalSupply;
    }
    
    /**
     * @dev Get pool information
     * @param pool The pool address
     * @return token0 Address of token0
     * @return token1 Address of token1
     * @return reserve0 Reserve of token0
     * @return reserve1 Reserve of token1
     */
    function getPoolInfo(address pool) external view returns (
        address token0,
        address token1,
        uint112 reserve0,
        uint112 reserve1
    ) {
        IUniswapV2Pair pair = IUniswapV2Pair(pool);
        token0 = pair.token0();
        token1 = pair.token1();
        (reserve0, reserve1,) = pair.getReserves();
    }
    
    /**
     * @dev Emergency function to recover stuck tokens
     */
    function emergencyRecoverToken(address token, uint256 amount) external onlyOwner {
        IERC20(token).transfer(owner, amount);
    }
    
    /**
     * @dev Transfer ownership
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "Invalid owner");
        owner = newOwner;
    }
}